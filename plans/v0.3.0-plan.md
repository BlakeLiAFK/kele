# Kele v0.3.0 开发计划：Daemon 拆分

## 一、之前的分析哪里错了

上一份架构审查（`architecture-review.md`）的核心结论是"Kele 不需要网关"。这个判断是错的。

错在把 Kele 当成了"一个 TUI 程序"。但 Kele 的设计文档（`docs/02-architecture/gateway.md`、`docs/03-core-features/autonomous-runtime.md`、`docs/03-core-features/heartbeat.md`）从一开始就描述了一个**常驻守护进程 + 多客户端**的架构。当前的实现是把所有东西塞进了 TUI 进程——这不是"不需要 daemon"，而是"还没拆出来"。

## 二、为什么必须有 Daemon

### 2.1 Cron 和 Heartbeat 需要常驻进程

当前 cron 调度器在 `tui/app.go` 的 `NewApp()` 里创建和启动：

```go
// tui/app.go:124
scheduler := cron.NewScheduler(cfg.Memory.DBPath, wd)
scheduler.Start()
```

**问题**：用户关掉终端，cron 就停了。这根本不是 cron，这是一个依附于 TUI 生命周期的定时器。真正的定时任务必须由一个不依赖终端的进程管理。

Heartbeat 更不用说——AI 自主决策需要后台长驻。

### 2.2 多客户端需要服务端

文档设计了 4 种客户端：CLI、Web 控制台、移动端、Agent Runtime。哪怕只实现 TUI + 未来的 Web UI，就已经是两个客户端了。两个客户端不可能各自内嵌一份 Brain + Memory + LLM Provider，那会：
- 数据库锁冲突（SQLite 单写）
- 上下文割裂（两边各自维护 history）
- API Key 和模型状态不一致

### 2.3 Daemon 就是网关

不需要单独引入"网关"这个概念。Daemon 本身就是网关：

| 网关概念 | Daemon 实现 |
|---------|------------|
| 连接管理 | 管理 TUI/Web/API 客户端的连接 |
| 事件路由 | 接收客户端请求，分发到对应会话 |
| 状态管理 | 持有 Brain、Memory、Provider 单例 |
| 渠道适配 | 未来接 WhatsApp/Telegram 的入口 |
| 心跳调度 | 常驻运行，不依赖终端 |

**一句话：Daemon 不是额外的东西，它是 Kele 应该有但还没写出来的核心进程。**

## 三、当前架构 vs 目标架构

### 现在（一体式，全在 TUI 进程里）

```
kele (单进程，用户关终端就全停)
├── main.go          → flag 解析 + 启动 TUI
├── tui/app.go       → UI + 流式适配 + 会话管理
├── tui/session.go   → 每个 Session 创建自己的 Brain
├── agent/brain.go   → 持有 Provider + Executor + Memory
├── llm/provider.go  → 3 个 LLM 供应商
├── tools/executor.go→ 工具注册 + 执行 + 审计
├── memory/store.go  → SQLite 数据库
└── cron/scheduler.go→ 定时任务（随 TUI 生死）
```

**每个 Session 创建自己的 Brain，每个 Brain 创建自己的 ProviderManager 和 Executor。9 个会话 = 9 套 Provider + 9 套 Executor + 9 份 Memory 连接。这不是多会话，这是资源浪费。**

### 目标（两个进程：Daemon + Client）

```
keled（守护进程，常驻后台）
├── cmd/keled/main.go
├── internal/daemon/
│   ├── daemon.go         → 生命周期管理（Start/Stop/Signal）
│   ├── api.go            → Unix Socket API 服务
│   └── session.go        → 会话路由（Lane 模型）
├── internal/agent/brain.go    → 唯一 Brain 实例
├── internal/llm/              → 唯一 ProviderManager
├── internal/tools/            → 唯一 Executor
├── internal/memory/store.go   → 唯一 DB 连接
├── internal/cron/             → 在 daemon 里运行，不随终端停
└── internal/heartbeat/        → 心跳系统（未来）

kele（TUI 客户端，按需启动）
├── cmd/kele/main.go
├── internal/tui/
│   ├── app.go            → 纯 UI：渲染 + 输入 + 事件显示
│   ├── commands.go       → 命令解析（发给 daemon 执行）
│   ├── client.go         → 连接 daemon 的 Unix Socket 客户端
│   └── ...               → view/keys/completion 基本不变
└── (不再 import agent/, llm/, memory/, tools/, cron/)
```

## 四、IPC 方案选择：Unix Socket

### 为什么不用 WebSocket

文档里写的 `ws://127.0.0.1:18789` 是 OpenClaw 的方案。OpenClaw 是 Node.js，WebSocket 是其生态自然选择。但 Kele 是 Go：

| 方案 | 优点 | 缺点 |
|------|------|------|
| WebSocket | 跨网络、浏览器原生支持 | 需要 HTTP server、端口占用、安全 |
| Unix Socket | 零配置、快、安全（文件权限）| 不跨网络、Windows 兼容性差 |
| gRPC | 强类型、代码生成 | 重依赖、protobuf 编译 |

**选 Unix Socket**，理由：
1. Kele 是本地工具，不需要跨网络
2. Unix Socket 不占端口，不需要额外安全配置
3. Go 标准库原生支持 `net.Dial("unix", path)`
4. 未来加 Web UI 时再加一个 HTTP/WebSocket 端点，不影响 Unix Socket

Socket 路径：`~/.kele/kele.sock`

### 协议：JSON-RPC over Unix Socket

不需要自定义协议。用 JSON 行协议（每行一个 JSON）：

**请求**（Client → Daemon）:
```json
{"id": "1", "method": "chat", "params": {"session": "default", "input": "你好"}}
{"id": "2", "method": "command", "params": {"command": "/status"}}
{"id": "3", "method": "chat.stream", "params": {"session": "s1", "input": "写个脚本"}}
```

**响应**（Daemon → Client）:
```json
{"id": "1", "result": {"content": "你好！有什么可以帮你的？"}}
{"id": "2", "result": {"content": "系统状态\n版本: ..."}}
```

**流式事件**（Daemon → Client，无 id 表示推送）:
```json
{"event": "stream", "session": "s1", "data": {"type": "thinking", "content": "让我想想..."}}
{"event": "stream", "session": "s1", "data": {"type": "content", "content": "这是一个"}}
{"event": "stream", "session": "s1", "data": {"type": "tool_call", "name": "bash"}}
{"event": "stream", "session": "s1", "data": {"type": "done"}}
```

**这直接消除了四层事件转换。Daemon 产出一种事件格式，Client 直接渲染，零转换。**

## 五、做减法：拆分后会删掉什么

### 5.1 TUI 层减法

| 删除/简化 | 原因 |
|-----------|------|
| `tui/app.go` 里的 `startStream()` 事件适配 (~30 行) | 不再需要 agent→tui 事件转换 |
| `tui/app.go` 里的 `streamEvent` 类型定义 | 直接用 daemon 推送的 JSON |
| `tui/session.go` 里创建 Brain | Session 不再持有 Brain |
| `tui/app.go` 里创建 Scheduler | Cron 在 daemon 里管理 |
| TUI 对 `agent/`, `llm/`, `memory/`, `cron/` 的直接 import | 全部通过 client.go 的 RPC 调用 |
| `tui/commands.go` 里直接操作 Brain 的 20+ 方法调用 | 变成发 RPC 请求 |

**预计 TUI 层从 3,242 行减少到 ~2,000 行。**

### 5.2 Agent 层减法

| 删除/简化 | 原因 |
|-----------|------|
| Brain 上 20+ 个 getter 方法（GetModel, GetSmallModel, ListProviders...） | 这些是给 TUI 用的透传，daemon 有 API 直接暴露 |
| `agent.StreamEvent` 类型 | daemon 用统一事件格式推送 |

### 5.3 Tools 层减法

| 删除/简化 | 原因 |
|-----------|------|
| `tools/registry.go` (90 行) | Executor 直接管理 map，不需要独立 Registry |
| Executor 里的 cron 硬编码 | Cron 工具注册为标准 ToolHandler |

## 六、实施计划

### Phase 1：Daemon 骨架（不改 TUI）

**目标**：让 `keled` 能启动、监听 Unix Socket、处理基本请求。TUI 暂不改动。

```
新增文件：
  cmd/keled/main.go           → daemon 入口
  internal/daemon/daemon.go   → 生命周期管理
  internal/daemon/api.go      → Unix Socket 服务 + JSON 协议
  internal/daemon/session.go  → 会话管理（Lane 模型）
```

**做的事**：
1. `keled start` 启动 daemon，创建 `~/.kele/kele.sock`
2. `keled stop` 发送停止信号
3. daemon 内部：创建唯一 Brain + ProviderManager + Executor + Memory + Scheduler
4. 监听 Unix Socket，接收 JSON-RPC 请求
5. 支持 `chat`、`chat.stream`、`command` 三种方法
6. 信号处理：SIGTERM/SIGINT → 优雅关闭

**不做的事**：
- 不改 TUI
- 不加 Heartbeat
- 不加渠道适配器

### Phase 2：TUI 瘦身（接入 Daemon）

**目标**：TUI 从内嵌 Brain 改为连接 Daemon。

```
新增文件：
  internal/tui/client.go      → daemon 客户端

修改文件：
  cmd/kele/main.go            → 启动时检查 daemon，未运行则自动启动
  internal/tui/app.go         → 删除 Brain/Scheduler 创建，用 client
  internal/tui/session.go     → 删除 Brain 字段，用 session ID
  internal/tui/commands.go    → 命令通过 client 发送给 daemon
```

**做的事**：
1. `kele` 启动时检查 `~/.kele/kele.sock` 是否存在
2. 不存在 → 自动 fork 启动 `keled`，等待 socket 就绪
3. 存在 → 直接连接
4. TUI 所有操作通过 `client.go` 发给 daemon
5. 流式响应通过 socket 推送接收
6. 删除 TUI 对 `agent/`, `llm/`, `memory/`, `cron/` 的直接依赖

**关键改动**：
- `Session` 不再持有 `*agent.Brain`，改为持有 `sessionID string`
- `handleCommand()` 不再直接调用 Brain 方法，改为 `client.SendCommand(cmd)`
- `startStream()` 不再适配事件类型，daemon 直接推送统一格式

### Phase 3：清理 + Cron 正规化

**目标**：消除遗留的过度设计。

**做的事**：
1. 删除 `tools/registry.go`，Executor 内联 map
2. 将 cron 工具从 Executor 硬编码改为标准 ToolHandler
3. 删除 Brain 上仅给 TUI 用的 getter 透传方法
4. 统一事件类型：删除 `agent.StreamEvent`、`tui.streamEvent`
5. 删除 `ollama.ListModels()`（死代码）或接入 API
6. 审计日志接入 `/audit` API 端点

### Phase 4：Heartbeat 系统

**目标**：实现 AI 自主心跳。

```
新增文件：
  internal/heartbeat/heartbeat.go  → 心跳调度
  internal/heartbeat/snapshot.go   → 系统快照采集
```

**做的事**：
1. daemon 启动时同时启动 heartbeat ticker
2. 每 15 分钟生成系统快照（CPU/内存/磁盘/待办/最近错误）
3. 读取 `HEARTBEAT.md` 配置
4. 将快照 + 配置发给 Brain，让 AI 决策
5. AI 可调用工具执行操作
6. 记录心跳历史到 SQLite

## 七、每个 Phase 的验收标准

### Phase 1 验收
- [ ] `go build ./cmd/keled` 编译通过
- [ ] `keled start` 创建 PID 文件和 socket 文件
- [ ] `keled stop` 正确停止进程
- [ ] 通过 `nc -U ~/.kele/kele.sock` 发 JSON 能收到响应
- [ ] daemon 日志写入 `~/.kele/daemon.log`
- [ ] `go test ./internal/daemon/...` 通过

### Phase 2 验收
- [ ] `kele` 启动时自动拉起 daemon
- [ ] 对话功能正常（通过 daemon 代理）
- [ ] 所有 slash 命令正常
- [ ] 流式输出正常
- [ ] 多会话正常
- [ ] TUI 不再 import `agent/`, `llm/`, `memory/`
- [ ] 关闭 TUI 后 daemon 继续运行
- [ ] 重新打开 TUI 能看到 cron 在后台执行的记录

### Phase 3 验收
- [ ] `tools/registry.go` 已删除
- [ ] Cron 工具走 ToolHandler 注册
- [ ] 事件类型全局统一为一种
- [ ] 所有测试通过
- [ ] `go vet ./...` 无警告

### Phase 4 验收
- [ ] `HEARTBEAT.md` 配置被 AI 读取并执行
- [ ] 心跳历史可通过 `/heartbeat` 命令查看
- [ ] 夜间自动降低心跳频率
- [ ] 心跳决策记录到审计日志

## 八、风险和决策

### 8.1 SQLite 并发

daemon 是单进程，不存在多写问题。但 TUI 客户端可能同时发多个请求。

**决策**：daemon 内部用 Lane 模型，同一会话串行处理。不同会话并行但各自操作独立数据，SQLite WAL 模式足够。

### 8.2 Daemon 死了怎么办

**决策**：
- daemon 写 PID 文件 (`~/.kele/kele.pid`)
- TUI 启动时检查 PID 是否存活，死了就重启
- daemon 自身用 recover 防 panic 扩散
- 未来可接入 systemd/launchd 做自动重启

### 8.3 向后兼容

**决策**：
- Phase 1 不改 TUI，daemon 是独立增量
- Phase 2 改 TUI 时保留 `--standalone` flag 支持无 daemon 模式（降级到当前行为）
- 降级模式在 Phase 4 之后废弃

### 8.4 Windows 兼容

Unix Socket 在 Windows 上需要 Go 1.24+（已满足，go.mod 里是 1.24.7）。Named Pipe 是备选但不必要。

## 九、不做什么

| 不做 | 理由 |
|------|------|
| WebSocket 网关 | 本地工具不需要跨网络通信 |
| gRPC | 过重，JSON-RPC 足够 |
| Prometheus 监控 | 当前阶段无需 |
| 多 daemon 实例 | 单用户工具，一个就够 |
| WhatsApp/Telegram 适配器 | v0.4.0+ 的事 |
| Web UI | v0.4.0+ 的事 |
| Command 接口 + CommandRegistry | 过度设计，分文件就够 |

## 十、工作量估算

| Phase | 新增行数 | 删除行数 | 核心文件数 | 复杂度 |
|-------|---------|---------|-----------|--------|
| Phase 1 | ~500 | 0 | 4 新 | 中 |
| Phase 2 | ~300 | ~800 | 5 改 + 1 新 | 高 |
| Phase 3 | ~50 | ~200 | 4 改 + 1 删 | 低 |
| Phase 4 | ~300 | 0 | 2 新 | 中 |
| **合计** | **~1,150** | **~1,000** | - | - |

**净增约 150 行代码，但架构从单体变成 client-server。**

## 十一、总结

| 问题 | 答案 |
|------|------|
| Kele 需要 daemon 吗？ | **需要。Cron、Heartbeat、多客户端都要求常驻进程。** |
| Daemon 就是网关吗？ | **是。Daemon = 网关 = 事件总线 + 会话路由 + 服务端。** |
| 这是加法还是减法？ | **架构上是加法（新增 daemon），代码上是减法（TUI 瘦身 ~800 行）。** |
| 之前的架构审查对吗？ | **判断错了。不是"不需要网关"，而是"daemon 就是网关"。** |
