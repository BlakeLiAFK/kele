# Kele v0.3.0 开发计划：单二进制三形态架构

## 一、之前的分析哪里错了

上一份架构审查（`architecture-review.md`）的核心结论是"Kele 不需要网关"。这个判断是错的。

错在把 Kele 当成了"一个 TUI 程序"。但 Kele 的设计文档（`docs/02-architecture/gateway.md`、`docs/03-core-features/autonomous-runtime.md`、`docs/03-core-features/heartbeat.md`）从一开始就描述了一个**常驻守护进程 + 多客户端**的架构。当前的实现是把所有东西塞进了 TUI 进程——这不是"不需要 daemon"，而是"还没拆出来"。

## 二、为什么必须有 Daemon

### 2.1 Cron 和 Heartbeat 需要常驻进程

当前 cron 调度器在 `tui/app.go` 的 `NewApp()` 里创建和启动：

```go
// tui/app.go:124
scheduler := cron.NewScheduler(cfg.Memory.DBPath, wd)
scheduler.Start()
```

**问题**：用户关掉终端，cron 就停了。这根本不是 cron，这是一个依附于 TUI 生命周期的定时器。真正的定时任务必须由一个不依赖终端的进程管理。

Heartbeat 更不用说——AI 自主决策需要后台长驻。

### 2.2 多客户端需要服务端

文档设计了 4 种客户端：CLI、Web 控制台、移动端、Agent Runtime。哪怕只实现 TUI + 未来的 Web UI，就已经是两个客户端了。两个客户端不可能各自内嵌一份 Brain + Memory + LLM Provider，那会：
- 数据库锁冲突（SQLite 单写）
- 上下文割裂（两边各自维护 history）
- API Key 和模型状态不一致

### 2.3 Daemon 就是网关

不需要单独引入"网关"这个概念。Daemon 本身就是网关：

| 网关概念 | Daemon 实现 |
|---------|------------|
| 连接管理 | 管理 TUI/Web/API 客户端的连接 |
| 事件路由 | 接收客户端请求，分发到对应会话 |
| 状态管理 | 持有 Brain、Memory、Provider 单例 |
| 渠道适配 | 未来接 WhatsApp/Telegram 的入口 |
| 心跳调度 | 常驻运行，不依赖终端 |

**一句话：Daemon 不是额外的东西，它是 Kele 应该有但还没写出来的核心进程。**

## 三、单二进制三形态

### 设计决策

**不需要两个二进制产物。** 统一用 `kele`，通过 cobra 子命令指定运行形态：

```bash
kele              # 默认 → TUI 模式（交互式界面）
kele daemon       # → Daemon 模式（后台常驻服务）
kele agent        # → Agent 模式（无头管道模式）
```

**为什么单二进制：**
1. 分发简单 — `go install` 或 `brew install` 一步到位
2. 自举能力 — TUI 发现没有 daemon 时，fork 自己 `kele daemon start`
3. 共享代码 — daemon、agent、TUI 共享 `internal/` 下所有包
4. 标准做法 — kubectl、docker、hugo 都是单二进制 + 子命令

### 三种形态定位

| 形态 | 命令 | 面向 | 职责 |
|------|------|------|------|
| **TUI** | `kele`（默认） | 人 | 交互式界面，连接 daemon，渲染对话 |
| **Daemon** | `kele daemon` | 系统 | 后台常驻，持有 Brain/Memory/LLM/Cron/Heartbeat |
| **Agent** | `kele agent` | 管道/脚本 | 无头模式，stdin→LLM→stdout，用于 CI/CD 和嵌入 |

### Cobra 命令树

```
kele                          → 默认启动 TUI
├── daemon                    → daemon 管理
│   ├── start [--foreground]  → 启动 daemon（默认后台 fork）
│   ├── stop                  → 停止 daemon
│   └── status                → 查看 daemon 状态
├── agent                     → 无头 agent 模式
│   ├── --session <id>        → 指定会话
│   ├── --model <model>       → 指定模型
│   └── --oneshot             → 单次问答（不保持连接）
├── version                   → 版本信息
└── 全局 flags
    ├── --config <path>       → 指定配置文件
    └── --debug               → 开启调试日志
```

### 当前架构 vs 目标架构

**现在（一体式，全在 TUI 进程里）**

```
kele (单进程，用户关终端就全停)
├── main.go          → flag 解析 + 启动 TUI
├── tui/app.go       → UI + 流式适配 + 会话管理
├── tui/session.go   → 每个 Session 创建自己的 Brain
├── agent/brain.go   → 持有 Provider + Executor + Memory
├── llm/provider.go  → 3 个 LLM 供应商
├── tools/executor.go→ 工具注册 + 执行 + 审计
├── memory/store.go  → SQLite 数据库
└── cron/scheduler.go→ 定时任务（随 TUI 生死）
```

**每个 Session 创建自己的 Brain，每个 Brain 创建自己的 ProviderManager 和 Executor。9 个会话 = 9 套 Provider + 9 套 Executor + 9 份 Memory 连接。这不是多会话，这是资源浪费。**

**目标（两个进程，单一二进制）**

```
kele（单一二进制，cobra 子命令切换形态）
├── cmd/kele/main.go             → cobra root command + 子命令注册
├── internal/cli/
│   ├── root.go                  → cobra root（默认 TUI）
│   ├── daemon.go                → kele daemon start/stop/status
│   ├── agent.go                 → kele agent 无头模式
│   └── version.go               → kele version
├── internal/daemon/
│   ├── daemon.go                → 生命周期管理（Start/Stop/Signal）
│   ├── api.go                   → Unix Socket API 服务
│   └── session.go               → 会话路由（Lane 模型）
├── internal/tui/
│   ├── app.go                   → 纯 UI：渲染 + 输入 + 事件显示
│   ├── commands.go              → 命令解析（发给 daemon 执行）
│   ├── client.go                → 连接 daemon 的 Unix Socket 客户端
│   └── ...                      → view/keys/completion 基本不变
├── internal/agent/brain.go      → 唯一 Brain 实例（daemon 持有）
├── internal/llm/                → 唯一 ProviderManager
├── internal/tools/              → 唯一 Executor
├── internal/memory/store.go     → 唯一 DB 连接
├── internal/cron/               → 在 daemon 里运行，不随终端停
└── internal/heartbeat/          → 心跳系统（未来）

TUI 模式不再 import agent/, llm/, memory/, tools/, cron/
Agent 模式连 daemon（和 TUI 走同样的 Unix Socket 协议）
```

## 四、IPC 方案：gRPC over Unix Socket

### 传输层：Unix Socket

Socket 路径：`~/.kele/kele.sock`

Unix Socket 优势：零配置、不占端口、文件权限即安全、Go 标准库原生支持。

### 协议层：gRPC + Protobuf

gRPC 优势：强类型、代码生成、原生支持 server-side streaming（完美适配 LLM 流式输出）。

```protobuf
// proto/kele.proto
service KeleService {
  rpc Chat(ChatRequest) returns (stream ChatEvent);      // 流式对话
  rpc Complete(CompleteRequest) returns (CompleteResponse); // AI 补全
  rpc RunCommand(RunCommandRequest) returns (RunCommandResponse); // 斜杠命令
  rpc CreateSession(CreateSessionRequest) returns (SessionInfo);
  rpc DeleteSession(DeleteSessionRequest) returns (Empty);
  rpc ListSessions(Empty) returns (ListSessionsResponse);
  rpc GetStatus(Empty) returns (StatusResponse);
  rpc GetHeartbeatStatus(Empty) returns (HeartbeatStatusResponse);
}
```

**gRPC server-side streaming 直接消除了四层事件转换。Daemon 的 ChatEvent 就是最终格式，Client 直接渲染，零转换。**

## 五、做减法：拆分后会删掉什么

### 5.1 TUI 层减法

| 删除/简化 | 原因 |
|-----------|------|
| `tui/app.go` 里的 `startStream()` 事件适配 (~30 行) | 不再需要 agent→tui 事件转换 |
| `tui/app.go` 里的 `streamEvent` 类型定义 | 直接用 gRPC ChatEvent |
| `tui/session.go` 里创建 Brain | Session 不再持有 Brain |
| `tui/app.go` 里创建 Scheduler | Cron 在 daemon 里管理 |
| TUI 对 `agent/`, `llm/`, `memory/`, `cron/` 的直接 import | 全部通过 client.go 的 RPC 调用 |
| `tui/commands.go` 里直接操作 Brain 的 20+ 方法调用 | 变成发 RPC 请求 |

**预计 TUI 层从 3,242 行减少到 ~2,000 行。**

### 5.2 Agent 层减法

| 删除/简化 | 原因 |
|-----------|------|
| Brain 上 20+ 个 getter 方法（GetModel, GetSmallModel, ListProviders...） | 这些是给 TUI 用的透传，daemon 有 API 直接暴露 |
| `agent.StreamEvent` 类型 | daemon 用统一事件格式推送 |

### 5.3 Tools 层减法

| 删除/简化 | 原因 |
|-----------|------|
| `tools/registry.go` (90 行) | Executor 直接管理 map，不需要独立 Registry |
| Executor 里的 cron 硬编码 | Cron 工具注册为标准 ToolHandler |

## 六、实施计划

### Phase 1：Cobra 骨架 + Daemon 基础（不改 TUI 功能）

**目标**：将 `kele` 从 raw flag 切换到 cobra，新增 `kele daemon start/stop/status`，让 daemon 能启动、监听 Unix Socket、处理基本请求。TUI 功能暂不改动。

```
新增文件：
  internal/cli/root.go        → cobra root command（默认启动 TUI）
  internal/cli/daemon.go      → kele daemon start/stop/status
  internal/cli/agent.go       → kele agent（占位，Phase 2 实现）
  internal/cli/version.go     → kele version
  internal/daemon/daemon.go   → 生命周期管理
  internal/daemon/api.go      → Unix Socket API 服务 + JSON 协议
  internal/daemon/session.go  → 会话管理（Lane 模型）

修改文件：
  cmd/kele/main.go            → 改为调用 cli.Execute()
  go.mod                      → 新增 github.com/spf13/cobra 依赖
```

**做的事**：
1. 引入 cobra，重构 `cmd/kele/main.go` 为 `cli.Execute()`
2. `kele` 默认行为不变（启动 TUI），通过 cobra root command 的 `RunE` 实现
3. `kele daemon start` 启动 daemon 进程，创建 `~/.kele/kele.sock` 和 `~/.kele/kele.pid`
4. `kele daemon start --foreground` 前台模式（调试用）
5. `kele daemon stop` 发送 SIGTERM 停止 daemon
6. `kele daemon status` 检查 daemon 是否运行
7. daemon 内部：创建唯一 Brain + ProviderManager + Executor + Memory + Scheduler
8. 监听 Unix Socket，接收 JSON-RPC 请求
9. 支持 `chat`、`chat.stream`、`command` 三种方法
10. 信号处理：SIGTERM/SIGINT → 优雅关闭

**不做的事**：
- 不改 TUI 的内部逻辑（保持直接 import agent/llm/memory）
- 不实现 agent 模式（仅占位）
- 不加 Heartbeat
- 不加渠道适配器

### Phase 2：TUI 瘦身 + Agent 模式

**目标**：TUI 从内嵌 Brain 改为连接 Daemon。实现 Agent 无头模式。

```
新增文件：
  internal/tui/client.go      → daemon Unix Socket 客户端

修改文件：
  internal/cli/root.go        → TUI 启动前检查 daemon，未运行则自动拉起
  internal/cli/agent.go       → 实现 agent 无头模式
  internal/tui/app.go         → 删除 Brain/Scheduler 创建，用 client
  internal/tui/session.go     → 删除 Brain 字段，用 session ID
  internal/tui/commands.go    → 命令通过 client 发送给 daemon
```

**做的事**：
1. `kele` 启动时检查 `~/.kele/kele.sock` 是否存在
2. 不存在 → 自动 fork 启动 `kele daemon start`，等待 socket 就绪
3. 存在 → 直接连接
4. TUI 所有操作通过 `client.go` 发给 daemon
5. 流式响应通过 socket 推送接收
6. 删除 TUI 对 `agent/`, `llm/`, `memory/`, `cron/` 的直接依赖
7. 实现 `kele agent` 无头模式：stdin→daemon→stdout，支持 `--oneshot` 和 `--session`

**关键改动**：
- `Session` 不再持有 `*agent.Brain`，改为持有 `sessionID string`
- `handleCommand()` 不再直接调用 Brain 方法，改为 `client.SendCommand(cmd)`
- `startStream()` 不再适配事件类型，daemon 直接推送统一格式

**Agent 模式行为**：
```bash
# 单次问答
echo "解释一下 goroutine" | kele agent --oneshot

# 管道模式
cat error.log | kele agent --model gpt-4o -p "分析这个错误日志"

# 持续会话
kele agent --session my-session
> 你好
< 你好！有什么可以帮你的？
> 帮我写个脚本
< ...
```

### Phase 3：清理 + Cron 正规化

**目标**：消除遗留的过度设计。

**做的事**：
1. 删除 `tools/registry.go`，Executor 内联 map
2. 将 cron 工具从 Executor 硬编码改为标准 ToolHandler
3. 删除 Brain 上仅给 TUI 用的 getter 透传方法
4. 统一事件类型：删除 `agent.StreamEvent`、`tui.streamEvent`
5. 删除 `ollama.ListModels()`（死代码）或接入 API
6. 审计日志接入 `/audit` API 端点

### Phase 4：Heartbeat 系统

**目标**：实现 AI 自主心跳。

```
新增文件：
  internal/heartbeat/heartbeat.go  → 心跳调度
  internal/heartbeat/snapshot.go   → 系统快照采集
```

**做的事**：
1. daemon 启动时同时启动 heartbeat ticker
2. 每 15 分钟生成系统快照（CPU/内存/磁盘/待办/最近错误）
3. 读取 `HEARTBEAT.md` 配置
4. 将快照 + 配置发给 Brain，让 AI 决策
5. AI 可调用工具执行操作
6. 记录心跳历史到 SQLite

## 七、每个 Phase 的验收标准

### Phase 1 验收
- [ ] `go build ./cmd/kele` 编译通过（单一二进制）
- [ ] `kele version` 输出版本信息
- [ ] `kele`（无参数）启动 TUI，行为与 v0.2.0 一致
- [ ] `kele daemon start` 创建 PID 文件和 socket 文件
- [ ] `kele daemon stop` 正确停止进程
- [ ] `kele daemon status` 显示运行状态
- [ ] 通过 `nc -U ~/.kele/kele.sock` 发 JSON 能收到响应
- [ ] daemon 日志写入 `~/.kele/daemon.log`
- [ ] `go test ./internal/daemon/...` 通过
- [ ] `go test ./internal/cli/...` 通过

### Phase 2 验收
- [ ] `kele` 启动时自动拉起 daemon（fork `kele daemon start`）
- [ ] 对话功能正常（通过 daemon 代理）
- [ ] 所有 slash 命令正常
- [ ] 流式输出正常
- [ ] 多会话正常
- [ ] TUI 不再 import `agent/`, `llm/`, `memory/`
- [ ] 关闭 TUI 后 daemon 继续运行
- [ ] 重新打开 TUI 能看到 cron 在后台执行的记录
- [ ] `kele agent --oneshot` 单次问答正常
- [ ] `echo "hello" | kele agent` 管道模式正常

### Phase 3 验收
- [ ] `tools/registry.go` 已删除
- [ ] Cron 工具走 ToolHandler 注册
- [ ] 事件类型全局统一为一种
- [ ] 所有测试通过
- [ ] `go vet ./...` 无警告

### Phase 4 验收
- [ ] `HEARTBEAT.md` 配置被 AI 读取并执行
- [ ] 心跳历史可通过 `/heartbeat` 命令查看
- [ ] 夜间自动降低心跳频率
- [ ] 心跳决策记录到审计日志

## 八、风险和决策

### 8.1 SQLite 并发

daemon 是单进程，不存在多写问题。但 TUI 客户端可能同时发多个请求。

**决策**：daemon 内部用 Lane 模型，同一会话串行处理。不同会话并行但各自操作独立数据，SQLite WAL 模式足够。

### 8.2 Daemon 死了怎么办

**决策**：
- daemon 写 PID 文件 (`~/.kele/kele.pid`)
- TUI 启动时检查 PID 是否存活，死了就执行 `kele daemon start`（同一个二进制，自举）
- daemon 自身用 recover 防 panic 扩散
- 未来可接入 systemd/launchd 做自动重启

### 8.3 向后兼容

**决策**：
- Phase 1 cobra 改造时保持 `kele`（无参数）行为完全一致
- Phase 2 改 TUI 时保留 `--standalone` flag 支持无 daemon 模式（降级到当前行为）
- 降级模式在 Phase 4 之后废弃

### 8.4 Windows 兼容

Unix Socket 在 Windows 上需要 Go 1.24+（已满足，go.mod 里是 1.24.7）。Named Pipe 是备选但不必要。

## 九、不做什么

| 不做 | 理由 |
|------|------|
| 多个二进制（kele + keled） | 单二进制 + cobra 更简洁，自举更方便 |
| WebSocket 网关 | 本地工具不需要跨网络通信 |
| JSON-RPC 自定义协议 | gRPC 提供强类型 + 流式支持，更可靠 |
| Prometheus 监控 | 当前阶段无需 |
| 多 daemon 实例 | 单用户工具，一个就够 |
| WhatsApp/Telegram 适配器 | v0.4.0+ 的事 |
| Web UI | v0.4.0+ 的事 |
| Command 接口 + CommandRegistry | 过度设计，分文件就够 |

## 十、工作量估算

| Phase | 新增行数 | 删除行数 | 核心文件数 | 复杂度 |
|-------|---------|---------|-----------|--------|
| Phase 1 | ~600 | ~50 | 7 新 + 1 改 | 中 |
| Phase 2 | ~400 | ~800 | 5 改 + 2 新 | 高 |
| Phase 3 | ~50 | ~200 | 4 改 + 1 删 | 低 |
| Phase 4 | ~300 | 0 | 2 新 | 中 |
| **合计** | **~1,350** | **~1,050** | - | - |

**净增约 300 行代码，但架构从单体变成 client-server 三形态。**

Phase 1 比原计划多 ~100 行，因为包含 cobra 骨架（root/daemon/agent/version 四个子命令文件）。

## 十一、总结

| 问题 | 答案 |
|------|------|
| Kele 需要 daemon 吗？ | **需要。Cron、Heartbeat、多客户端都要求常驻进程。** |
| Daemon 就是网关吗？ | **是。Daemon = 网关 = 事件总线 + 会话路由 + 服务端。** |
| 为什么单二进制？ | **分发简单、自举方便、cobra 是 Go 标准做法。** |
| 三种形态？ | **TUI（面向人）、Daemon（面向系统）、Agent（面向管道/脚本）。** |
| 这是加法还是减法？ | **架构上是加法（新增 daemon + agent），代码上是减法（TUI 瘦身 ~800 行）。** |
| 之前的架构审查对吗？ | **判断错了。不是"不需要网关"，而是"daemon 就是网关"。** |
