# v0.4.0 — TaskBoard: 看板任务系统 + 工作区

## 概述

在 daemon 端实现一个看板（Kanban）式任务管理与编排系统。核心能力：

1. **目标分解** — 用户给出模糊目标，Planner Agent 自动分析代码库并拆分为结构化子任务
2. **任务看板** — 每个任务有清晰的生命周期状态（backlog → ready → running → done/failed）
3. **多 Agent 并行执行** — 调度器自动为就绪任务创建 Agent session，多任务并行运行
4. **跨任务上下文传递** — 有依赖关系的任务自动注入前置任务的执行结果
5. **全局状态可见** — 用户通过 CLI/TUI/gRPC 实时查看所有工作区和任务的状态
6. **工作区隔离** — 不同工作区独立管理、独立并发控制，可同时运行多组任务
7. **结果汇总** — 工作区所有任务完成后，自动生成整体报告

## 完整工作流

```
用户: "帮我给 kele 加上看板功能"
            │
            ▼
┌─────────────────────────────┐
│  ① Planner Agent (规划器)    │  ← AI 读代码、分析架构、拆分任务
│  - 读取代码库上下文           │
│  - 理解用户意图               │
│  - 输出结构化任务计划 (JSON)  │
└──────────────┬──────────────┘
               │
               ▼
┌─────────────────────────────┐
│  ② 用户审阅 / 确认           │  ← 可修改、增删任务，调整依赖
│  Plan → Workspace + Tasks   │
└──────────────┬──────────────┘
               │ approve
               ▼
┌─────────────────────────────┐
│  ③ Board 调度执行            │  ← 调度器自动分配 agent session
│  - 依赖解析 → ready 队列     │
│  - 并发控制 → agent 执行     │
│  - 跨任务上下文注入           │  ← task B 拿到 task A 的 result
│  - 状态实时广播               │
└──────────────┬──────────────┘
               │ all done
               ▼
┌─────────────────────────────┐
│  ④ 结果汇总 (Synthesizer)    │  ← 汇总所有任务结果，生成报告
│  - 聚合各任务 result          │
│  - 生成完成报告               │
│  - 通知用户                   │
└─────────────────────────────┘
```

## 核心概念

### Workspace（工作区）

```
Workspace
├── Name / Description
├── Goal: string             ← 用户的原始目标（模糊表述）
├── Status: active | paused | archived
├── MaxConcurrent: 3         ← 最多同时运行几个 agent
├── Context: string          ← 注入到所有任务 session 的 system prompt（Planner 生成）
├── WorkDir: string          ← 任务执行的工作目录
├── Summary: string          ← Synthesizer 生成的完成报告
└── Tasks[]                  ← 该工作区下的所有任务
```

工作区是任务的逻辑分组。例如：
- `kele-v0.4` — kele 自身开发任务
- `ops-monitoring` — 运维监控任务
- `data-pipeline` — 数据处理管道

每个工作区有独立的并发上限。暂停工作区后，不会调度新任务，但已运行的不中断。

### Task（任务）

```
Task
├── ID: string (uuid)
├── WorkspaceID: string
├── Title: string
├── Description: string       ← 人读的描述
├── Prompt: string            ← 发给 Agent 的实际 prompt
├── Status: backlog | ready | running | done | failed | cancelled
├── Priority: 0-3             ← 0=critical, 1=high, 2=normal, 3=low
├── DependsOn: []TaskID       ← 前置依赖（全部 done 才可执行）
├── AssignedSession: string   ← 正在执行此任务的 session ID
├── Result: string            ← Agent 最终输出
├── Error: string             ← 失败原因
├── MaxRetries: int           ← 最大重试次数
├── RetryCount: int           ← 已重试次数
├── CreatedAt / StartedAt / CompletedAt
├── Tags: []string            ← 自定义标签，方便过滤
```

### 任务生命周期

```
             ┌─────────┐
             │ backlog  │  ← 用户创建，尚未细化
             └────┬─────┘
                  │ 用户确认 / 自动（deps satisfied）
                  ▼
             ┌─────────┐
             │  ready   │  ← 所有前置依赖 done，等待调度
             └────┬─────┘
                  │ 调度器分配 agent
                  ▼
             ┌─────────┐
             │ running  │  ← Agent session 正在执行
             └────┬─────┘
            ┌─────┼─────┐
            ▼     ▼     ▼
         ┌─────┐┌────┐┌──────────┐
         │done ││fail││cancelled │
         └─────┘└──┬─┘└──────────┘
                   │ retry（未超限）
                   ▼
              ┌─────────┐
              │  ready   │
              └──────────┘
```

**状态转换规则：**
- `backlog → ready`：用户手动确认，或创建时无 deps 则直接 ready
- `ready → running`：调度器自动（或用户手动 StartTask）
- `running → done`：Agent session ChatStream 正常结束
- `running → failed`：Agent 出错或工具轮次耗尽
- `failed → ready`：自动重试（retryCount < maxRetries）或用户手动 RetryTask
- `* → cancelled`：用户取消

### Board（看板 / 编排器）

Board 是 daemon 端的核心组件，职责：

1. **CRUD** — 工作区和任务的增删改查
2. **依赖解析** — 监听任务状态变化，自动将 deps 满足的 backlog 任务提升为 ready
3. **调度** — 为 ready 任务分配 agent session 并启动执行
4. **跨任务上下文** — 执行时自动注入前置任务的结果
5. **监控** — 跟踪 running 任务，收集输出，处理完成/失败
6. **事件广播** — 通过 gRPC streaming 推送状态变更事件
7. **结果汇总** — 工作区所有任务完成后触发 Synthesizer

### Planner（规划器）

Planner 是把模糊目标变成结构化任务计划的 AI Agent。它是整个系统的入口。

```
Planner
├── 输入: 用户目标 (string) + 可选上下文
├── 工作方式: 创建临时 session，用工具读代码分析架构
├── 输出: PlanResult
│   ├── workspace_name
│   ├── workspace_context (自动生成的 system prompt)
│   └── tasks[] (title, description, prompt, priority, depends_on)
└── 用户可审阅、修改后确认执行
```

**Planner 的 AI Prompt 模板：**

```
你是一个任务规划专家。用户给出了一个目标，你需要：

1. 使用工具读取相关代码和文件，充分理解当前代码库的架构
2. 将用户目标分解为具体的、可独立执行的子任务
3. 每个子任务应该是一个 agent 能独立完成的工作单元
4. 明确任务间的依赖关系（哪些必须先完成才能开始后续任务）
5. 按优先级排序

用户目标: {goal}

请输出 JSON 格式的任务计划:
{
  "workspace_name": "...",
  "workspace_context": "给所有执行 agent 的共享上下文...",
  "tasks": [
    {
      "title": "简短标题",
      "description": "人读的描述",
      "prompt": "给执行 agent 的完整、详细的 prompt（包括具体文件路径、实现要求等）",
      "priority": 1,
      "depends_on": [],          // 依赖的任务索引
      "tags": ["backend"]
    },
    ...
  ]
}
```

**关键设计：Planner prompt 的质量决定整个系统的效果。** Planner 必须：
- 有工具访问权（read, bash, grep）来实际了解代码库
- 生成的 task prompt 要足够具体，包含文件路径、函数签名、设计约束
- 合理拆分粒度：太粗（一个任务做太多事）→ 容易失败；太细（改一行代码）→ 调度开销大
- 理想粒度：一个任务 = 一个文件/模块级别的改动

### 跨任务上下文传递

当任务 B 依赖任务 A 时，执行 B 的 agent 需要知道 A 做了什么。

**机制：调度器在构建 task prompt 时自动注入依赖任务的结果。**

```
原始 prompt: "实现 Board 编排器的 CRUD 方法..."

注入后的 prompt:
---
## 前置任务结果

### [t-001] 定义数据类型 (已完成)
创建了 internal/taskboard/types.go，定义了以下类型：
- TaskStatus: backlog, ready, running, done, failed, cancelled
- Task 结构体包含 ID, WorkspaceID, Title, Prompt, Status, DependsOn...
- Workspace 结构体包含 ID, Name, MaxConcurrent, Context...
（结果摘要，最多 2000 字符）

---

## 你的任务
实现 Board 编排器的 CRUD 方法...
```

**实现方式：**
```go
func (s *Scheduler) buildTaskPrompt(task *Task) string {
    var b strings.Builder

    // 注入依赖任务的结果
    deps := s.store.GetDependencyResults(task.DependsOn)
    if len(deps) > 0 {
        b.WriteString("## 前置任务结果\n\n")
        for _, dep := range deps {
            b.WriteString(fmt.Sprintf("### [%s] %s (已完成)\n", dep.ID, dep.Title))
            b.WriteString(truncate(dep.Result, 2000))
            b.WriteString("\n\n")
        }
        b.WriteString("---\n\n")
    }

    // 原始 prompt
    b.WriteString("## 你的任务\n\n")
    b.WriteString(task.Prompt)
    return b.String()
}
```

### 结果汇总（Synthesizer）

当工作区中所有任务都完成（done）后，Board 自动触发汇总：

```go
func (b *Board) onTaskCompleted(ws *Workspace, task *Task) {
    // 检查工作区是否全部完成
    stats := b.store.CountByStatus(ws.ID)
    if stats.Backlog+stats.Ready+stats.Running == 0 && stats.Done > 0 {
        go b.synthesize(ws)
    }
}

func (b *Board) synthesize(ws *Workspace) {
    tasks := b.store.ListTasks(ws.ID, "done")

    // 创建汇总 session
    sess := b.sessions.Create(fmt.Sprintf("synth:%s", ws.ID))
    prompt := buildSynthesisPrompt(ws, tasks)

    // AI 汇总
    events, _ := sess.brain.ChatStream(prompt)
    var result strings.Builder
    for ev := range events {
        if ev.Type == "content" {
            result.WriteString(ev.Content)
        }
    }

    // 存储汇总结果
    ws.Summary = result.String()
    b.store.UpdateWorkspace(ws)
    b.broadcast(WorkspaceCompleted, ws)
    b.sessions.Delete(sess.ID)
}
```

汇总 prompt:
```
以下是工作区 "{ws.Name}" 中所有已完成任务的结果。
请生成一份简洁的完成报告，包括：
1. 完成了什么
2. 修改/创建了哪些文件
3. 是否有需要注意的问题

{各任务 title + result 列表}
```

## 架构设计

### 组件关系

```
┌──────────────────────────────────────────────────────────────┐
│                          Daemon                               │
│                                                               │
│  用户目标                                                      │
│     │                                                         │
│     ▼                                                         │
│  ┌───────────┐   plan    ┌──────────────┐   ┌──────────────┐ │
│  │  Planner  │ ────────► │    Board     │──►│  TaskStore   │ │
│  │  (AI 分解) │           │ (Orchestrator)│   │  (SQLite)    │ │
│  └───────────┘           └──────┬───────┘   └──────────────┘ │
│                                 │                              │
│                    ┌────────────┼────────────┐                 │
│                    │            │            │                  │
│                    ▼            ▼            ▼                  │
│  ┌──────────┐  [Session1]  [Session2]  [Session3]              │
│  │ Sessions  │  (task-A)    (task-B)    (task-C)               │
│  │ Manager   │     │            │           │                  │
│  └──────────┘     └────────────┼───────────┘                  │
│                                │ all done                      │
│                                ▼                               │
│                         ┌──────────────┐                       │
│                         │ Synthesizer  │                       │
│                         │ (结果汇总)    │                       │
│                         └──────────────┘                       │
│                                                               │
│  ┌──────────────────────────────────────────────────────┐     │
│  │                   gRPC Service                        │     │
│  │  PlanWorkspace | WatchBoard | GetBoardOverview | ...  │     │
│  └──────────────────────────────────────────────────────┘     │
└──────────────────────────────────────────────────────────────┘
          ▲           ▲            ▲
          │           │            │
        [TUI]    [CLI board]    [Agent]
```

### 数据流全景

```
① kele board plan "给 kele 加看板功能"
   │
   ▼
② Planner Agent session (带工具: read, bash, grep)
   │ 读代码 → 分析架构 → 拆分任务
   ▼
③ PlanResult {workspace, tasks[]} 返回客户端
   │
   ▼
④ 用户审阅: kele board show-plan → 修改 → kele board approve
   │
   ▼
⑤ Board.CreateFromPlan() → workspace + N tasks 写入 SQLite
   │
   ▼
⑥ Scheduler 循环检测:
   ├→ task-1 (no deps) → ready → 创建 session → ChatStream → done
   ├→ task-2 (deps: t1) → t1 done → 注入 t1.result → ready → running → done
   ├→ task-3 (deps: t1) → 同上，与 t2 并行
   └→ task-4 (deps: t2,t3) → 等 t2+t3 都 done → 注入两者 result → running → done
   │
   ▼
⑦ 全部 done → Synthesizer → 汇总报告 → workspace.summary
   │
   ▼
⑧ BoardEvent{WorkspaceCompleted} → 通知客户端
```

### 调度器工作流程

```go
func (b *Board) scheduleLoop() {
    for {
        select {
        case <-b.triggerCh:  // 任务状态变化触发
        case <-ticker.C:     // 定期兜底检查（5s）
        case <-b.stopCh:
            return
        }

        for _, ws := range b.activeWorkspaces() {
            if ws.Status != Active { continue }
            running := b.countRunning(ws.ID)
            if running >= ws.MaxConcurrent { continue }

            slots := ws.MaxConcurrent - running
            readyTasks := b.getReadyTasks(ws.ID, slots)  // 按优先级排序

            for _, task := range readyTasks {
                b.executeTask(ws, task)
            }
        }
    }
}
```

### 任务执行流程

```go
func (s *Scheduler) executeTask(ws *Workspace, task *Task) {
    // 1. 创建专属 session
    sess := s.sessions.Create(fmt.Sprintf("task:%s", task.ID))

    // 2. 注入工作区上下文到 session 的 system prompt
    if ws.Context != "" {
        sess.brain.InjectContext(ws.Context)
    }

    // 3. 构建最终 prompt（注入前置依赖结果）
    prompt := s.buildTaskPrompt(task)

    // 4. 更新任务状态
    task.Status = Running
    task.AssignedSession = sess.ID
    task.StartedAt = time.Now()
    s.board.store.UpdateTask(task)
    s.board.broadcast(TaskStarted, task)

    // 5. 异步执行
    go func() {
        result, err := s.runTaskSession(sess, task, prompt)
        if err != nil {
            task.Status = Failed
            task.Error = err.Error()
            task.RetryCount++
            if task.RetryCount < task.MaxRetries {
                task.Status = Ready  // 自动重试
            }
        } else {
            task.Status = Done
            task.Result = result
            task.CompletedAt = time.Now()
        }

        s.board.store.UpdateTask(task)
        s.board.broadcast(TaskCompleted, task)
        s.sessions.Delete(sess.ID)

        // 触发: ① 依赖解析（下游任务提升为 ready） ② 检查是否全部完成
        s.board.onTaskFinished(ws, task)
        s.trigger()
    }()
}

// buildTaskPrompt 将前置任务的结果注入到当前任务的 prompt 中
func (s *Scheduler) buildTaskPrompt(task *Task) string {
    var b strings.Builder

    // 获取已完成的依赖任务结果
    if len(task.DependsOn) > 0 {
        deps := s.board.store.GetTasksByIDs(task.DependsOn)
        hasDeps := false
        for _, dep := range deps {
            if dep.Status == Done && dep.Result != "" {
                if !hasDeps {
                    b.WriteString("## 前置任务结果\n\n")
                    hasDeps = true
                }
                b.WriteString(fmt.Sprintf("### [%s] %s\n", dep.ID, dep.Title))
                b.WriteString(truncateResult(dep.Result, 2000))
                b.WriteString("\n\n")
            }
        }
        if hasDeps {
            b.WriteString("---\n\n")
        }
    }

    b.WriteString(task.Prompt)
    return b.String()
}
```

### 事件广播

Board 维护一个事件总线，所有状态变化都广播为 `BoardEvent`：

```
BoardEvent
├── Type: task_created | task_started | task_completed | task_failed |
│         workspace_created | workspace_paused | ...
├── WorkspaceID
├── TaskID
├── Timestamp
└── Detail: string
```

gRPC `WatchBoard` RPC 订阅此总线，客户端实时接收更新。

## 数据持久化

### SQLite 表结构

在现有 `memory.Store` 的数据库中新增表（或使用独立的 `taskboard.db`）：

```sql
CREATE TABLE IF NOT EXISTS workspaces (
    id          TEXT PRIMARY KEY,
    name        TEXT NOT NULL,
    description TEXT DEFAULT '',
    goal        TEXT DEFAULT '',           -- 用户的原始目标
    status      TEXT DEFAULT 'active',     -- active, paused, archived
    max_concurrent INTEGER DEFAULT 3,
    context     TEXT DEFAULT '',            -- Planner 生成的 system prompt
    work_dir    TEXT DEFAULT '',
    summary     TEXT DEFAULT '',            -- Synthesizer 生成的完成报告
    created_at  DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at  DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS tasks (
    id          TEXT PRIMARY KEY,
    workspace_id TEXT NOT NULL REFERENCES workspaces(id),
    title       TEXT NOT NULL,
    description TEXT DEFAULT '',
    prompt      TEXT NOT NULL,
    status      TEXT DEFAULT 'backlog',  -- backlog, ready, running, done, failed, cancelled
    priority    INTEGER DEFAULT 2,       -- 0=critical, 1=high, 2=normal, 3=low
    assigned_session TEXT DEFAULT '',
    result      TEXT DEFAULT '',
    error       TEXT DEFAULT '',
    max_retries INTEGER DEFAULT 1,
    retry_count INTEGER DEFAULT 0,
    tags        TEXT DEFAULT '[]',        -- JSON array
    depends_on  TEXT DEFAULT '[]',        -- JSON array of task IDs
    created_at  DATETIME DEFAULT CURRENT_TIMESTAMP,
    started_at  DATETIME,
    completed_at DATETIME
);

CREATE INDEX IF NOT EXISTS idx_tasks_workspace ON tasks(workspace_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);

CREATE TABLE IF NOT EXISTS task_logs (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id     TEXT NOT NULL REFERENCES tasks(id),
    event_type  TEXT NOT NULL,  -- content, tool_call, tool_result, error, thinking
    content     TEXT DEFAULT '',
    tool_name   TEXT DEFAULT '',
    timestamp   DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_task_logs_task ON task_logs(task_id);
```

**设计决策：独立数据库 vs 复用 memory.db**

选择**独立数据库** `~/.kele/taskboard.db`：
- 避免任务数据和聊天记忆混淆
- 独立备份、迁移
- 不增加 memory.Store 的复杂度

## gRPC API 设计

### 新增 Proto 定义

```protobuf
// ==================== Workspace ====================

message WorkspaceInfo {
    string id = 1;
    string name = 2;
    string description = 3;
    string status = 4;
    int32  max_concurrent = 5;
    string context = 6;
    string work_dir = 7;
    int32  task_count = 8;
    int32  running_count = 9;
    string created_at = 10;
}

message CreateWorkspaceRequest {
    string name = 1;
    string description = 2;
    string goal = 3;
    int32  max_concurrent = 4;
    string context = 5;
    string work_dir = 6;
}

// ==================== Planner ====================

message PlanWorkspaceRequest {
    string goal = 1;              // 用户的模糊目标
    string work_dir = 2;          // 工作目录（供 Planner 读代码）
    int32  max_concurrent = 3;    // 期望并发数
}

// Planner 返回的计划（streaming，因为 AI 需要时间思考和读代码）
message PlanEvent {
    string type = 1;              // thinking, reading, plan_ready, error
    string content = 2;           // thinking/reading 过程信息
    string plan_json = 3;         // type=plan_ready 时，完整 JSON 计划
}

message ApprovePlanRequest {
    string plan_json = 1;         // 用户可能修改过的计划 JSON
    bool   auto_start = 2;        // 批准后是否自动开始执行
}

message ApprovePlanResponse {
    WorkspaceInfo workspace = 1;
    repeated TaskInfo tasks = 2;
}

message UpdateWorkspaceRequest {
    string id = 1;
    string name = 2;
    string description = 3;
    int32  max_concurrent = 4;
    string context = 5;
    string status = 6;  // active, paused, archived
}

message GetWorkspaceRequest { string id = 1; }
message DeleteWorkspaceRequest { string id = 1; }
message ListWorkspacesRequest {}

message ListWorkspacesResponse {
    repeated WorkspaceInfo workspaces = 1;
}

// ==================== Task ====================

message TaskInfo {
    string id = 1;
    string workspace_id = 2;
    string title = 3;
    string description = 4;
    string prompt = 5;
    string status = 6;
    int32  priority = 7;
    repeated string depends_on = 8;
    string assigned_session = 9;
    string result = 10;
    string error = 11;
    int32  retry_count = 12;
    int32  max_retries = 13;
    repeated string tags = 14;
    string created_at = 15;
    string started_at = 16;
    string completed_at = 17;
}

message CreateTaskRequest {
    string workspace_id = 1;
    string title = 2;
    string description = 3;
    string prompt = 4;
    int32  priority = 5;
    repeated string depends_on = 6;
    int32  max_retries = 7;
    repeated string tags = 8;
    bool   auto_ready = 9;  // true = 跳过 backlog，直接 ready
}

message UpdateTaskRequest {
    string id = 1;
    string title = 2;
    string description = 3;
    string prompt = 4;
    int32  priority = 5;
    repeated string tags = 6;
}

message GetTaskRequest { string id = 1; }
message DeleteTaskRequest { string id = 1; }

message ListTasksRequest {
    string workspace_id = 1;   // 可选，空则返回所有
    string status_filter = 2;  // 可选，逗号分隔
    string tag_filter = 3;     // 可选
}

message ListTasksResponse {
    repeated TaskInfo tasks = 1;
}

message StartTaskRequest { string id = 1; }
message CancelTaskRequest { string id = 1; }
message RetryTaskRequest { string id = 1; }

// ==================== Board Overview ====================

message BoardOverview {
    repeated WorkspaceOverview workspaces = 1;
    int32 total_tasks = 2;
    int32 running_tasks = 3;
    int32 pending_tasks = 4;
    int32 completed_tasks = 5;
}

message WorkspaceOverview {
    string id = 1;
    string name = 2;
    string status = 3;
    int32  backlog = 4;
    int32  ready = 5;
    int32  running = 6;
    int32  done = 7;
    int32  failed = 8;
    int32  max_concurrent = 9;
}

// ==================== Board Events (streaming) ====================

message WatchBoardRequest {
    string workspace_id = 1;  // 可选，空则监听所有
}

message BoardEvent {
    string type = 1;           // task_created, task_started, task_completed, task_failed,
                               // task_cancelled, workspace_created, workspace_paused, ...
    string workspace_id = 2;
    string task_id = 3;
    string detail = 4;
    string timestamp = 5;
}

// ==================== Task Log ====================

message GetTaskLogRequest {
    string task_id = 1;
    int32  limit = 2;   // 最近 N 条，默认 100
}

message TaskLogEntry {
    string event_type = 1;
    string content = 2;
    string tool_name = 3;
    string timestamp = 4;
}

message TaskLogResponse {
    repeated TaskLogEntry entries = 1;
}
```

### 新增 RPC

```protobuf
service KeleService {
    // ... 现有 8 个 RPC ...

    // Workspace
    rpc CreateWorkspace(CreateWorkspaceRequest) returns (WorkspaceInfo);
    rpc GetWorkspace(GetWorkspaceRequest) returns (WorkspaceInfo);
    rpc UpdateWorkspace(UpdateWorkspaceRequest) returns (WorkspaceInfo);
    rpc DeleteWorkspace(DeleteWorkspaceRequest) returns (Empty);
    rpc ListWorkspaces(ListWorkspacesRequest) returns (ListWorkspacesResponse);

    // Task
    rpc CreateTask(CreateTaskRequest) returns (TaskInfo);
    rpc GetTask(GetTaskRequest) returns (TaskInfo);
    rpc UpdateTask(UpdateTaskRequest) returns (TaskInfo);
    rpc DeleteTask(DeleteTaskRequest) returns (Empty);
    rpc ListTasks(ListTasksRequest) returns (ListTasksResponse);

    // Task execution
    rpc StartTask(StartTaskRequest) returns (TaskInfo);
    rpc CancelTask(CancelTaskRequest) returns (TaskInfo);
    rpc RetryTask(RetryTaskRequest) returns (TaskInfo);

    // Planner (目标分解)
    rpc PlanWorkspace(PlanWorkspaceRequest) returns (stream PlanEvent);
    rpc ApprovePlan(ApprovePlanRequest) returns (ApprovePlanResponse);

    // Board
    rpc GetBoardOverview(Empty) returns (BoardOverview);
    rpc WatchBoard(WatchBoardRequest) returns (stream BoardEvent);

    // Task log
    rpc GetTaskLog(GetTaskLogRequest) returns (TaskLogResponse);
}
```

**总计新增 18 个 RPC**（原有 8 个 → 26 个）

## 文件结构

```
internal/taskboard/
├── types.go        # TaskStatus, WorkspaceStatus 枚举，Task, Workspace, PlanResult 结构体
├── store.go        # SQLite CRUD（独立 taskboard.db）
├── board.go        # Board 编排器：CRUD + 事件总线 + onTaskFinished 触发汇总
├── scheduler.go    # 调度循环：依赖解析 + 并发控制 + 上下文注入 + 任务执行
└── planner.go      # Planner: 目标分解 AI Agent + Synthesizer 汇总逻辑
```

### 各文件职责

**types.go** (~100 行)
- `TaskStatus` / `WorkspaceStatus` 常量
- `Task` / `Workspace` 结构体（Workspace 包含 Goal, Summary 字段）
- `BoardEvent` 事件类型
- `TaskLog` 日志条目
- `PlanResult` / `PlannedTask` — Planner 输出的结构化计划
- 状态转换验证方法

**store.go** (~350 行)
- `TaskStore` 结构体（持有 `*sql.DB`）
- `NewTaskStore(dbPath)` — 打开/创建数据库
- Workspace CRUD: `CreateWorkspace`, `GetWorkspace`, `UpdateWorkspace`, `DeleteWorkspace`, `ListWorkspaces`
- Task CRUD: `CreateTask`, `GetTask`, `UpdateTask`, `DeleteTask`, `ListTasks`
- 查询: `GetReadyTasks(wsID, limit)`, `CountByStatus(wsID)`, `GetDependents(taskID)`
- 批量: `GetTasksByIDs(ids)` — 获取依赖任务结果，`CreateFromPlan(plan)` — 从计划批量创建
- 日志: `AppendTaskLog`, `GetTaskLog`
- 恢复: `RecoverRunningTasks()` — daemon 重启时 running → ready

**board.go** (~300 行)
- `Board` 结构体（持有 store, sessions, provider, executor, planner, eventBus）
- `NewBoard(store, sessions, provider, executor)` 构造
- Workspace 方法: `CreateWorkspace`, `PauseWorkspace`, `ResumeWorkspace`, `GetOverview`
- Task 方法: `CreateTask`, `StartTask`, `CancelTask`, `RetryTask`
- `onTaskFinished(ws, task)` — 依赖提升 + 检查是否全部完成 → 触发汇总
- 事件总线: `Subscribe() <-chan BoardEvent`, `broadcast(event)`

**scheduler.go** (~250 行)
- `Scheduler` 结构体（持有 board, sessions, stop/trigger channels）
- `Start()` / `Stop()` 生命周期
- `scheduleLoop()` — 主循环（事件驱动 + 定时兜底）
- `executeTask(ws, task)` — 创建 session、注入上下文、异步执行
- `buildTaskPrompt(task)` — **核心：注入前置依赖任务的 result**
- `runTaskSession(sess, task, prompt)` — 调用 ChatStream、收集输出、记录 task_logs
- `resolveDependencies(taskID)` — 任务完成后检查并提升下游任务为 ready

**planner.go** (~250 行)
- `Planner` 结构体（持有 provider, executor, sessions）
- `Plan(goal, workDir string) (<-chan PlanEvent, error)` — streaming 输出规划过程
  - 创建临时 session（有工具访问权：read, bash, grep）
  - 发送规划 prompt → AI 读代码 → 输出 JSON 计划
  - 流式返回 thinking/reading/plan_ready 事件
- `ParsePlan(jsonStr string) (*PlanResult, error)` — 解析 AI 输出的 JSON
- `ApproveAndCreate(plan *PlanResult, autoStart bool) (*Workspace, []*Task, error)`
  - 创建 workspace + 批量创建 tasks
  - autoStart=true 时直接激活调度
- `Synthesize(ws *Workspace) (string, error)` — 汇总所有已完成任务，生成报告

## 修改现有文件

### proto/kele.proto
新增上述 18 个 RPC + 所有 message 定义

### internal/daemon/daemon.go
- 新增 `board *taskboard.Board` 字段
- `initResources()` 中创建 `TaskStore` + `Board`，启动调度器
- `cleanup()` 中停止调度器

### internal/daemon/server.go
- 实现 18 个新 RPC handler（均委托给 `d.board.*`）

### internal/daemon/session.go
- `SessionBrain` 新增 `InjectContext(ctx string)` 方法 — 在 system prompt 中追加工作区上下文
- `SessionBrain` 新增 `GetHistory() []llm.Message` — 供 task log 记录

### internal/cli/root.go
- 注册 `board` 子命令组

### 新增 CLI 命令

**internal/cli/board.go** — Board 总览 + 规划
```
kele board                              # 看板总览（所有工作区统计）
kele board plan "给 kele 加看板功能"      # ⭐ 核心入口：AI 目标分解
kele board approve                       # 审阅并批准计划
kele board watch [--workspace <id>]      # 实时监听事件流
```

**internal/cli/workspace.go** — 工作区管理
```
kele workspace create <name> [--max-concurrent 3] [--context "..."]
kele workspace list
kele workspace show <id>                 # 详情 + 任务列表
kele workspace pause <id>
kele workspace resume <id>
kele workspace delete <id>
kele workspace summary <id>              # 查看完成报告
```

**internal/cli/task.go** — 任务管理
```
kele task create <workspace-id> --title "..." --prompt "..." [--priority 1] [--depends t1,t2]
kele task list [--workspace <id>] [--status ready,running]
kele task show <id>                      # 详情 + 依赖 + 结果
kele task start <id>                     # 手动触发执行
kele task cancel <id>
kele task retry <id>
kele task log <id>                       # 查看执行日志
```

## 实现阶段

### Phase 1: 数据层 + 核心类型
**文件:** `types.go`, `store.go`

1. `internal/taskboard/types.go` — 所有类型定义（含 PlanResult）
2. `internal/taskboard/store.go` — SQLite 持久化（CRUD + 批量创建 + 恢复）

### Phase 2: Board 编排器 + 调度器
**文件:** `board.go`, `scheduler.go`

1. `internal/taskboard/board.go` — Board CRUD + 事件总线 + onTaskFinished
2. `internal/taskboard/scheduler.go` — 调度循环 + buildTaskPrompt (跨任务上下文注入) + 执行

### Phase 3: Planner + Synthesizer
**文件:** `planner.go`

1. `internal/taskboard/planner.go` — AI 目标分解 + 计划解析 + 批量创建 + 汇总

### Phase 4: gRPC 集成
**文件:** `proto/kele.proto`, `server.go`, `daemon.go`, `session.go`

1. 更新 `proto/kele.proto` + 重新生成代码 (`protoc`)
2. 修改 `internal/daemon/daemon.go` — Board 生命周期管理
3. 修改 `internal/daemon/session.go` — `InjectContext()` 方法
4. 修改 `internal/daemon/server.go` — 实现 18 个新 RPC

### Phase 5: CLI 命令
**文件:** `internal/cli/board.go`, `workspace.go`, `task.go`

1. `internal/cli/board.go` — `kele board` 总览 + `plan` + `approve` + `watch`
2. `internal/cli/workspace.go` — 工作区 CRUD
3. `internal/cli/task.go` — 任务管理 + 执行控制

### Phase 6: 构建 + 测试 + 提交

## 使用场景示例

### 场景 1: AI 目标分解 → 自动执行（核心流程）

```bash
# ⭐ 一句话启动：AI 自动分析代码库并拆分任务
$ kele board plan "给 kele 加上看板功能，支持工作区和任务管理"

[Planner] 正在分析代码库...
[Planner] 读取 internal/daemon/daemon.go...
[Planner] 读取 proto/kele.proto...
[Planner] 读取 internal/daemon/session.go...
[Planner] 分析完成，生成任务计划:

  工作区: kele-taskboard
  并发数: 2
  任务数: 6

  #1  定义数据类型 (types.go)               优先级: critical  依赖: 无
  #2  实现 SQLite 持久化 (store.go)          优先级: high     依赖: #1
  #3  实现 Board 编排器 (board.go)           优先级: high     依赖: #1
  #4  实现调度器 (scheduler.go)              优先级: high     依赖: #2, #3
  #5  更新 gRPC proto + server 实现          优先级: normal   依赖: #1
  #6  添加 CLI 命令 (board/workspace/task)   优先级: normal   依赖: #4, #5

  确认执行? [Y/n/edit]

# 用户可以:
# - Y: 直接批准
# - n: 放弃
# - edit: 打开编辑器修改计划 JSON

$ Y

[Board] 创建工作区 kele-taskboard (6 任务)
[Board] #1 "定义数据类型" → running
[Board] ...

# 实时监听执行进度
$ kele board watch
[14:30:01] ● task_started    #1 "定义数据类型"
[14:31:15] ✓ task_completed  #1 "定义数据类型"
[14:31:15] ● task_started    #2 "实现 SQLite 持久化"      ← t1 完成，t2 就绪
[14:31:15] ● task_started    #3 "实现 Board 编排器"        ← t2/t3 并行（max 2 slots）
[14:31:16]   task_ready      #5 "更新 gRPC proto"          ← t1 完成，t5 就绪（等 slot）
[14:33:40] ✓ task_completed  #2 "实现 SQLite 持久化"
[14:33:40] ● task_started    #5 "更新 gRPC proto"          ← slot 释放
[14:34:22] ✓ task_completed  #3 "实现 Board 编排器"
[14:35:00] ✓ task_completed  #5 "更新 gRPC proto"
[14:35:00] ● task_started    #4 "实现调度器"               ← t2+t3 完成
[14:36:11] ✓ task_completed  #4 "实现调度器"
[14:36:11] ● task_started    #6 "添加 CLI 命令"            ← t4+t5 完成
[14:37:45] ✓ task_completed  #6 "添加 CLI 命令"

[Synthesizer] 所有任务完成，生成报告...
✅ 工作区 kele-taskboard 完成 (6/6 tasks, 7m44s)

# 查看汇总报告
$ kele workspace summary kele-taskboard
```

注意 #2 的 agent 收到的 prompt 是这样的（跨任务上下文自动注入）：

```
## 前置任务结果

### [#1] 定义数据类型
创建了 internal/taskboard/types.go，定义了：
- TaskStatus: backlog, ready, running, done, failed, cancelled
- Task 结构体 (ID, WorkspaceID, Title, Prompt, Status, DependsOn...)
- Workspace 结构体 (ID, Name, Goal, MaxConcurrent, Context, Summary...)
- PlanResult 结构体 ...

---

## 你的任务
在 internal/taskboard/store.go 中实现 SQLite 持久化层...
（store.go 的详细 prompt）
```

### 场景 2: 手动创建任务（精细控制）

```bash
# 也可以跳过 Planner，直接手动创建
kele workspace create "daily-check" --max-concurrent 5

kele task create daily-check --title "检查磁盘" \
  --prompt "检查所有磁盘使用率，超过80%告警" --auto-ready
kele task create daily-check --title "检查日志" \
  --prompt "检查 /var/log/syslog 最近1小时的 ERROR" --auto-ready
kele task create daily-check --title "检查服务" \
  --prompt "检查 nginx, postgres, redis 服务状态" --auto-ready
# 三个任务同时并行执行

kele board
# ┌────────────────────────────────────────┐
# │  daily-check  [active]  3/5 slots      │
# ├──────────┬────────┬──────────┬─────────┤
# │ Backlog  │ Ready  │ Running  │  Done   │
# │          │        │ 检查磁盘 ●│         │
# │          │        │ 检查日志 ●│         │
# │          │        │ 检查服务 ●│         │
# └──────────┴────────┴──────────┴─────────┘
```

### 场景 3: TUI 内操作

```
/board                        # 显示看板总览
/board plan "重构 config 模块" # AI 分解 → 审阅 → 执行
/task list                    # 列出当前任务
/task log t-001               # 查看某任务的执行日志
```

## 关键设计决策

| 决策 | 选择 | 理由 |
|------|------|------|
| 目标分解 | Planner Agent (带工具的 LLM session) | 需要读代码才能拆出有意义的任务 |
| Planner 输出 | 结构化 JSON + streaming 过程 | 可解析、可编辑、可审阅 |
| 跨任务上下文 | 构建 prompt 时注入 deps 的 result | 简单直接，不需要共享内存 |
| result 截断 | 每个 dep result 最多 2000 字符 | 防止 prompt 超长 |
| 结果汇总 | 全部 done 时自动触发 Synthesizer | 用户不用手动触发，体验流畅 |
| 存储 | 独立 SQLite (taskboard.db) | 与聊天记忆解耦，独立生命周期 |
| 调度 | 事件驱动 + 定时兜底 | 状态变化触发即时调度，定时防遗漏 |
| 任务执行 | 复用 SessionBrain + ChatStream | 已有完整的工具调用链，无需重建 |
| 任务-Session 关系 | 1:1 临时 session | 任务完成后清理，不占用资源 |
| 并发控制 | per-workspace 级别 | 不同工作区互不影响 |
| 日志 | 独立 task_logs 表 | ChatEvent 流持久化，支持回放 |
| 事件推送 | gRPC server-side streaming | 与现有 Chat streaming 一致 |
| 依赖解析 | 任务完成时 fan-out 检查 | 简单高效，无需复杂 DAG 引擎 |
| 重启恢复 | running → ready 回退 | daemon 重启后任务自动重新调度 |
